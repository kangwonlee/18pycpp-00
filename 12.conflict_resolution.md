# 병합 충돌과 충돌 해소<br>Merge conflict and conflict resolution

## 병합 충돌이란 무엇인가?<br>What is the "Merge conflict"?

* 수정사항이 겹치는 경우 충돌이 발생할 수 있음.<br>Overlaps of changes may cause the merge conflict.
* `git`에서, 소스코드는 수정사항(==커밋)을 모은 것으로 생각될 수 있음.<br>In `git`, a source code file can be regarded as an accumulation of changes, i.e., commits.
* 예를 들어 `git merge` 명령은 두 branch `A`, `B`를 합쳐서 하나의 commit 으로 만들고자 함.<br>For example, `git merge` intend to create one commit out of two branches `A` & `B`.
* 각각의 branch 는 여러 commit을 포함할 수 있음.<br>(예를 들어 `A` branch 에는 `A1`, `A2`, `A3` commit 이, `B` branch 에는 `B1`, `B2` commit 이 포함)<br>Each branch may include multiple commits.<br>(for example, branches `A` and `B` may include commits `A1`, `A2`, & `A3` and `B1` & `B2` respectively)

### 충돌 없이 병합 가능한 경우 <br>Would merge without conflict if ...

* 각 branch 에서 변경이 일어났던 위치가 서로 겹치지 않는다면 충돌은 일어나지 않음.<br>If locations of changes in each branch are not indentical, there would be no conflicts.
* 예를 들어, `A` branch 의 `A1`, `A2`, & `A3` commit 은 `foo.txt` 파일만, `B` branch 의 `B1` & `B2` commit 은 `goo.txt` 파일만 수정하였다면, 병합 중 충돌은 일어나지 않을 것임.<br>If `A1`, `A2`, & `A3` commits of branch `A` modified `foo.txt` file only, and `B1` & `B2` commits of branch `B` changed `goo.txt` file only, there would be no conflict during the merge.
* 다른 예로, `A` branch 의 commit이 `foo.txt` 파일의 1-10 행을, `C` branch 의 commit이 해당 `foo.txt` 파일의 20-30행 만을 수정하였다면, 병합 중 충돌은 일어나지 않을 것임.<br>Differently, if commits of `A` branch modified lines 1-10 of `foo.txt` file, and commits of `C` branch changed lines 20-30 of the same `foo.txt` file, `git` would probably be able to merge `A` and `C` branches without much problem.
* 수정한 위치가 겹치는 경우라도, 해당 위치의 수정 내용이 같다면, 충돌은 일어나지 않음.<br>Even when the changes overlap, if both branches have the same changes at the overlapping location, merge would complete successfully.

### 충돌이 일어날 경우 <br>Would conflict if ...

* 어떤 파일의 특정 행이 두 branch 에서 모두 수정되었는데, 각 branch 의 내용이 다른 경우, `git` 가 어느 branch 의 내용을 사용해야 할지 알 수 없기 때문에 **충돌**이 발생.<br>When specific lines of a certain file was modified in both branches, and each branch has different changes, `git` cannot decide to apply changes from which branch; thus merge would **conflict**.

## 충돌 해소 절차 예<br>An example of conflict resolution process

### repl.it 에서 shell 사용 중 발생할 경우<br>For `bash` in repl.it

* repl.it의 repl 안에서 shell 사용 중 의도하지 않게 재설정될 수 있음.<br>The shell of a repl of repl.it may unintentionally reset.
* 만일 원격 저장소(예: github.com)에 push 한 직후 재설정되면, repl 의 지역 저장소 내용이 몇 commit 이전으로 돌아갈 수 있음.<br>If reset happens right after `git push` to the remote repository, i.e., github, the local repository may go back to a few commits ago.
* 이후 repl 에서 원격 저장소로 push 하기 전에, `git pull` 로 원격 저장소에만 있는 commit을 repl의 지역 저장소에 반영해 주어야 함.<br>Before next `git push` to the remote repository, `git pull` must apply commits only in the remote repository to the local repository of the repl.
* 재설정 이후 repl에 추가된 commit이 github 의 수정 사항과 위치는 같지만 내용이 다르다면, `git pull` 실행 중 충돌이 발생할 것임.<br>If repl commits after reset are on the same locations with those of the remote repository but different in contents, `git pull` would conflict.
* 충돌을 해소하기 위해 아래와 같은 절차를 생각해 볼 수 있음.<br>We can think about following procedure to resolve the conflict

`git stash`<br>
`git fetch`<br>
`git log --oneline --graph --all`<br>
`git diff origin/master` 이용 충돌유무파악<br>
문제 없을시 `git merge origin/master` 갈라진 가지 합치기<br>
하다가 conflict 발생가능(깃허브에 이미 푸쉬 but repl에서 다르게 수정)<br>
```
<<<<<<<<<<<
1
===========
2
>>>>>>>>>>>
```
1이나 2중 하나 선택해야함<br>
`git add <conflict 되었다는 파일>`<br>
`git commit`<br>
깃허브 저장소 만들어서 연습<br>
